import requests

class Node:
    def __init__(self, order):
        self.order = order
        self.keys = []
        self.children = []

    def is_leaf(self):
        return not bool(self.children)

class BPlusTree:
    def __init__(self, order=3):
        self.order = order
        self.root = Node(order)

    def insert(self, key, value):
        new_child = self._insert(self.root, key, value)
        if new_child:
            new_root = Node(self.order)
            new_root.keys = [new_child.keys.pop(0)]
            new_root.children = [self.root, new_child]
            self.root = new_root

    def search(self, key, api_key):
        coordinates = self._search(self.root, key)
        if coordinates:
            return self._get_temperature(coordinates, api_key)
        return None

    def _insert(self, node, key, value):
        if node.is_leaf():
            node.keys.append((key, value))
            node.keys.sort(key=lambda x: x[0])
            if len(node.keys) < self.order:
                return None
            return self._split_leaf_node(node)
        else:
            child = self._select_child(node, key)
            new_child = self._insert(child, key, value)
            if not new_child:
                return None
            i = node.children.index(child)
            node.keys.insert(i, new_child.keys.pop(0))
            node.children.insert(i + 1, new_child)
            if len(node.keys) < self.order:
                return None
            return self._split_internal_node(node)

    def _split_leaf_node(self, node):
        new_node = Node(self.order)
        midpoint = len(node.keys) // 2
        new_node.keys = node.keys[midpoint:]
        node.keys = node.keys[:midpoint]
        return new_node

    def _split_internal_node(self, node):
        new_node = Node(self.order)
        midpoint = len(node.keys) // 2
        new_node.keys = node.keys[midpoint + 1:]
        new_node.children = node.children[midpoint + 1:]
        node.keys = node.keys[:midpoint]
        node.children = node.children[:midpoint + 1]
        return new_node

    def _search(self, node, key):
        if node.is_leaf():
            for k, v in node.keys:
                if k == key:
                    return v
            return None
        else:
            child = self._select_child(node, key)
            return self._search(child, key)

    def _select_child(self, node, key):
        for i, k in enumerate(node.keys):
            if key < k[0]:
                return node.children[i]
        return node.children[-1]

    def _get_temperature(self, coordinates, api_key):
        lat, lon = coordinates
        url = f"http://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={api_key}&units=imperial"
        response = requests.get(url)
        data = response.json()

        if data["cod"] != 200:
            print(f"Error fetching temperature data: {data['message']}")
            return None

        temperature = data["main"]["temp"]
        return temperature

def fetch_cities(search_term, api_key):
    url = f"http://api.openweathermap.org/geo/1.0/direct?q={search_term}&limit=5&appid={api_key}"
    response = requests.get(url)
    data = response.json()

    if not data:
        print(f"No cities found with the search term: {search_term}")
        return []

    cities = [{"name": city["name"], "coord": {"lat": city["lat"], "lon": city["lon"]}} for city in data]
    return cities

# Example usage
bplus_tree = BPlusTree(order=5)
api_key = "22a4a6b8c95cae3bd78f317a1094c245"

# Fetch cities using a search term and insert them into the B+ tree
search_term = "New York"
cities = fetch_cities(search_term, api_key)

for city in cities:
    bplus_tree.insert(city["name"].lower(), (city["coord"]["lat"], city["coord"]["lon"]))

# Search for a city and display its temperature
city_name = "New York"
temperature = bplus_tree.search(city_name.lower(), api_key)

if temperature:
    print(f"Temperature in {city_name}: {temperature} F")
else:
    print(f"City '{city_name}' not found in the B+ tree.")

