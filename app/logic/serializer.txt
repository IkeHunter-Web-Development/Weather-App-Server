"""
Weather API Serializers
"""
from rest_framework import serializers
from django.db.models import QuerySet
from drf_queryfields import QueryFieldsMixin
from .models import Summary, ConditionsList, Forecast, ForecastTable, ForecastRow


class ConditionsListSerializer(serializers.ModelSerializer):
    class Meta:
        model = ConditionsList
        fields = ('__all__')
        # fields = ('title', 'average_temp', 'feels_like', 'pressure', \
        #           'humidity', 'wind_speed', 'pop', 'rain_level')
class ForecastRowSerializer(serializers.ModelSerializer):
    class Meta:
        model = ForecastRow
        fields = ('value', 'time')

class ForecastTableSerializer(serializers.ModelSerializer):
    # values = ForecastRowSerializer()
    values = serializers.SerializerMethodField()


    class Meta:
        model = ForecastTable
        fields = ('__all__')
        # depth=1

    # def create(self, validated_data):
    #     print(validated_data)
    #     forecast_row = validated_data.pop('forecast_row')


    def get_values(self, obj: ForecastTable) -> QuerySet:
        # values: QuerySet = ForecastRow.objects.filter(
        #     # forecast_row_id=obj.id
        # ).values()
        values: QuerySet = ForecastRow.objects.all().values()
        return values



class ForecastSerializer(serializers.ModelSerializer):
    # table = ForecastTableSerializer(many=True)
    table = serializers.SerializerMethodField()

    class Meta:
        model = Forecast
        fields = ('__all__')

    # def create(self, validated_data):
    #     forecast_table = validated_data.pop('table')
    #     forecast_instance = Forecast.objects.create(**validated_data)

    #     for table in forecast_table:
    #         ForecastTable.objects.create(forecast=forecast_instance, **table)
    #     return forecast_instance

    def get_table(self, obj: Forecast) -> QuerySet:
        # table: QuerySet = ForecastTable.objects.filter(
        #     forecast_id=obj.id
        # ).values()
        table: QuerySet = ForecastTable.objects.all().values()
        return table





class SummarySerializer(serializers.ModelSerializer):
    # current_conditions = ConditionsListSerializer(many=False)
    # lastYear = ConditionsListSerializer(many=False)
    # forecast = ForecastSerializer(many=False)

    # current_conditions = serializers.SerializerMethodField()
    # last_year = serializers.SerializerMethodField()
    # forecast = serializers.SerializerMethodField()
    # forecast = ForecastSerializer(many=True)
    forecast = ForecastSerializer


    class Meta:
        model = Summary
        fields = ('__all__')
        # depth = 1

    # def create(self, validated_data):
    #     # forecast = Forecast(*validated_data)
    #     # validated_data.pop()
    #     print("being created")
    #     print(validated_data)
    #     # return Summary(**validated_data)

    def get_current_conditions(self, obj: Summary) -> QuerySet:
        current_conditions: QuerySet = ConditionsList.objects.filter(
            location_id=obj.id,
            widget_title="Current Conditions"
        ).values()
        return current_conditions # all this code probably breaks due to summary_id
    def get_last_year(self, obj: Summary) -> QuerySet:

        last_year: QuerySet = ConditionsList.objects.filter(
            location_id=obj.id,
            widget_title="Last Year"
        ).values()
        return last_year
    def get_forecast(self, obj: Summary) -> QuerySet:
        # forecast: QuerySet = Forecast.objects.filter(
        #     location_id=obj.id,
        # ).values()
        # forecast: QuerySet = Forecast.objects.all().values()
        forecast = ForecastSerializer(many=True)
        print(forecast)
        return forecast


